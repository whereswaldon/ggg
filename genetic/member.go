package genetic

import (
	"fmt"
	//	"math"
	"strings"
)

/**
Member represents a single member of the solution polulation.
Genes contains the set of genes of that member
*/
type Member struct {
	Genes []*Gene
	//data generated by gene functions, if any
	data [][]uint8

	//fitness score
	fitness int
	//indicates whether the genes have mutated since last data and fitness were generated
	mutated bool
}

/**
ByFitnessAsc is a slice of Members sorted by their fitness score relative to the target
in order of ascending fitness
*/
type ByFitnessAsc []*Member

/**
Len returns the length of the slice of sorted Members.
*/
func (f ByFitnessAsc) Len() int {
	return len(f)
}

/**
Swap implements swapping two elements of the ByFitness sorted
slice of Members.
*/
func (f ByFitnessAsc) Swap(i, j int) {
	f[i], f[j] = f[j], f[i]
}

/**
Less returns true if the Member at position i is less fit than the member at
position j
*/
func (f ByFitnessAsc) Less(i, j int) bool {
	return f[i].GetFitness() < f[j].GetFitness()
}

/**
ByFitness is a slice of Members sorted by their fitness score relative to the
target in order of descending fitness.
*/
type ByFitnessDesc []*Member

/**
Len returns the length of the slice of sorted Members.
*/
func (f ByFitnessDesc) Len() int {
	return len(f)
}

/**
Swap implements swapping two elements of the ByFitness sorted
slice of Members.
*/
func (f ByFitnessDesc) Swap(i, j int) {
	f[i], f[j] = f[j], f[i]
}

/**
Less returns true if the Member at position i is less fit than the member at
position j
*/
func (f ByFitnessDesc) Less(i, j int) bool {
	return f[i].GetFitness() > f[j].GetFitness()
}

/**
NewMember creates a new member of the population with 1 to 10 genes
*/
func NewMember() *Member {
	//create between 1 and 10 genes
	genes := make([]*Gene, murphy.Intn(10)+1)

	for i := range genes {
		genes[i] = NewGene()
	}
	return &Member{genes, nil, 0, false}
}

/**
String returns a string representation of the member with
each of its Gene functions printed on a new line
*/
func (mem *Member) String() string {
	stringGenes := make([]string, len(mem.Genes))
	for i, v := range mem.Genes {
		stringGenes[i] = v.String()
	}
	return fmt.Sprintf("Member:\t(fitness: %d)\n\t%s", mem.GetFitness(), strings.Join(stringGenes, "\n\t"))
}

/**
GetData retrieves the data array generated by this Member's gene functions.
*/
func (mem *Member) GetData() [][]uint8 {
	if mem.data == nil || mem.mutated {
		mem.data = mem.createDataArray(TargetHeight, TargetWidth)
		mem.mutated = false
		return mem.data
	}
	return mem.data
}

/**
Mutate changes this members genes by adding a gene function,
removing a gene function, or modifying an existing function.
*/
func (mem *Member) Mutate() {
	mem.mutated = true
	numGenes := len(mem.Genes)
	dieRoll := murphy.Intn(20)
	switch dieRoll {
	case 0:
		//delete a gene
		if numGenes > 1 {
			mem.deleteFirstGene()
			//fmt.Println("Lost a gene.")
		} else {
			//add a gene
			mem.addGeneAtEnd()
			//fmt.Println("Gained a gene.")
		}
	case 1:
		fallthrough
	case 2:
		//add a gene
		mem.addGeneAtEnd()
		//fmt.Println("Gained a gene.")
	default:
		//mutate an existing gene
		victim := murphy.Intn(numGenes)
		mem.Genes[victim].Mutate()
		//fmt.Printf("Changed gene %d\n", victim)
	}
}

/**
Removes the first Gene function from the member's genes
*/
func (mem *Member) deleteFirstGene() {
	mem.Genes = mem.Genes[1:]
}

/**
addGeneAtEnd inserts a new gene function at the end of a member's genes
*/
func (mem *Member) addGeneAtEnd() {
	mem.Genes = append(mem.Genes, NewGene())
}

/*
GetFitness returns an integer score representing how closely this member's
data aligns with the target data. Low scores are better.
*/
func (mem *Member) GetFitness() int {
	if mem.mutated || mem.fitness == 0 {
		mem.fitness = mem.computeFitness()
	}
	return mem.fitness
}

/**
computeFitness computes the fitness score of a given member as an integer.
*/
func (mem *Member) computeFitness() int {
	data := mem.GetData()
	offBy := 0
	for y := range Target {
		for x := range Target[y] {
			offBy += similarity(data[y][x], Target[y][x])
		}
	}

	return offBy
}

/**
similarity returns an integer that is closer to 255 the closer together the two
operands are.
*/
func similarity(data, target uint8) int {
	return int((data - target) * (data - target))
}

/**
createDataArray uses the genes of this member to create a two-dimensional
array of data by using indicies into that array as the input to the Member's
Gene functions
*/
func (mem *Member) createDataArray(arrayHeight, arrayWidth int) [][]uint8 {
	data := make([][]uint8, arrayHeight)
	for y := range data {
		data[y] = make([]uint8, arrayWidth)

		//insert data
		for x := range data[y] {
			data[y][x] = mem.EvalGenesAt(x, y)
		}
	}

	return data
}

/**
Eval genes at finds the sum of the gene functions at a particular coordinate pair
*/
func (mem *Member) EvalGenesAt(xCoord, yCoord int) (val uint8) {
	defer func() {
		if recovery := recover(); recovery != nil {
			val = 255
		}
	}()
	for _, g := range mem.Genes {
		val += uint8(g.EvalWith(xCoord, yCoord))
	}
	return val
}

/**
Cross takes the genes of the two given Members and creates a "child" Member from them
with attributes of both of its "parents"
*/
func Cross(m1, m2 *Member) *Member {
	depth1 := murphy.Intn(len(m1.Genes)) + 1
	depth2 := murphy.Intn(len(m2.Genes))
	zygote1 := m1.Genes[:depth1]
	zygote2 := m2.Genes[depth2:]

	genes := make([]*Gene, len(zygote1)+len(zygote2))

	geneIndex := 0
	for i, v := range zygote1 {
		genes[i] = v.Copy()
		geneIndex++
	}

	for _, v := range zygote2 {
		genes[geneIndex] = v.Copy()
		geneIndex++
	}

	return &Member{genes, nil, 0, false}
}
